
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                background-color: #000000;
                margin: 0px;
                overflow: hidden;
                font-family:Monospace;
                font-size:13px;
                text-align:center;
                font-weight: bold;
                text-align:center;
            }

            a {
                color:#0078ff;
            }

            #info {
                color:#fff;
                position: absolute;
                top: 0px; width: 100%;
                padding: 5px;
                z-index:100;
            }

        </style>
    </head>
    <body>


        <script src="three.min.js"></script>
        <script src="tween.min.js"></script>

        <script src="stats.min.js"></script>
        <script src="pusher.color.js"></script>
        <img id="globeImage" style="display:none" src="equirectangle_projection.png"/>
        <script src="globeutils.js"></script>

        <script>


            var container, stats;
            var camera, scene, renderer, particles, geometry, material, i, h, color, colors = [], sprite, size;
            var mouseX = 0, mouseY = 0;

            var windowHalfX = window.innerWidth / 2;
            var windowHalfY = window.innerHeight / 2;
            cameraDistance = 2500;
            cameraAngle=(Math.PI * 2) * .5;

            var pointAnimations = [];
            var markerAnimations = [];

            var markerGeometry = [];


            var lastRenderDate = new Date();


            function addPointAnimation(when, verticleIndex, position){
                var pCount = pointAnimations.length-1;
                while(pCount > 0 && pointAnimations[pCount].when < when){
                    pCount--;
                }
                pointAnimations.splice(pCount+1,0, {when: when, verticleIndex: verticleIndex, position: position});
            }

            function runPointAnimations(){
                var next;

                if(pointAnimations.length == 0){
                    return;
                }

                while(pointAnimations.length > 0 && (next = pointAnimations.pop()).when < Date.now()){
                    particles.geometry.vertices[next.verticleIndex].x = next.position.x;
                    particles.geometry.vertices[next.verticleIndex].y = next.position.y;
                    particles.geometry.vertices[next.verticleIndex].z = next.position.z;

                    particles.geometry.verticesNeedUpdate = true;
                }
                if(next.when >= Date.now()){
                    pointAnimations.push(next);

                }

            }


            function init() {

            }

            var markerMaterial = new THREE.LineBasicMaterial({
                color: 0x8FD8D8,
                });


            function addMarker(lat, lng, text){

                var point = mapPoint(lat,lng);

                var markerGeometry = new THREE.Geometry();
                markerGeometry.vertices.push(new THREE.Vector3(point.x, point.y, point.z));
                markerGeometry.vertices.push(new THREE.Vector3(point.x, point.y, point.z));

                var line = new THREE.Line(markerGeometry, markerMaterial);


                scene.add(line);

                var textSprite = createLabel(text, point.x*1.2, point.y*1.2, point.z*1.2, 20, "white");
                // textMesh.rotateY(Math.PI/2 - cameraAngle);
 
                scene.add(textSprite);

                new TWEEN.Tween(point)
                    .to( {x: point.x*1.2, y: point.y*1.2, z: point.z*1.2}, 1500 )
                    .easing( TWEEN.Easing.Elastic.InOut )
                    .onUpdate(function(){
                        markerGeometry.vertices[1].x = this.x;
                        markerGeometry.vertices[1].y = this.y;
                        markerGeometry.vertices[1].z = this.z;
                        markerGeometry.verticesNeedUpdate = true;
                    })
                    .start();

                    
                setTimeout(function(){
                    var markerTop = new THREE.Sprite(new THREE.SpriteMaterial({color: 0x8FD8D8}));
                    markerTop.position = {x: point.x, y: point.y, z: point.z};
                    markerTop.scale.set(10, 10);
                    scene.add(markerTop);

                    var materialSpline = new THREE.LineBasicMaterial({
                        color: 0x222222,
                        transparent: true,
                        opacity: 0
                    });
                    trailerSplines = [];
                    trailerCurves = [];

                    new TWEEN.Tween( {opacity: 0.0})
                        .to( {opacity: 0.2}, 3500 )
                        .onUpdate(function(){
                            materialSpline.opacity = this.opacity;
                        })
                        .start();


                    for(var i = 0; i< 10; i++){
                        trailerSplines[i] = new THREE.Geometry();

                        var lenBase = 4;
                        var sPoints = [];

                        for(var j = 0; j< lenBase; j++){
                            var thisPoint = mapPoint(lat, lng - j*(Math.random()*3+1));
                            sPoints.push(new THREE.Vector3(thisPoint.x*1.2, thisPoint.y*1.2, thisPoint.z*1.2));
                        }

                        var spline = new THREE.SplineCurve3(sPoints);

                        var splinePoints = spline.getPoints(10);

                        for(var k = 0; k < splinePoints.length; k++){
                            trailerSplines[i].vertices.push(splinePoints[k]);  
                        }
                        trailerCurves[i] = new THREE.Line(trailerSplines[i], materialSpline);
                        scene.add(trailerCurves[i]);
                    }




                },1500);




            }

            function createLabel(text, x, y, z, size, color, backGroundColor, backgroundMargin) {
                if(!backgroundMargin)
                backgroundMargin = 50;

                var canvas = document.createElement("canvas");

                var context = canvas.getContext("2d");
                context.font = size + "pt Arial";

                var textWidth = context.measureText(text).width;

                canvas.width = textWidth;
                canvas.height = size;
                context = canvas.getContext("2d");
                context.font = size + "pt Arial";

                context.textAlign = "center";
                context.textBaseline = "middle";
                context.fillStyle = color;
                context.fillText(text, canvas.width / 2, canvas.height / 2);

                // context.strokeStyle = "black";
                // context.strokeRect(0, 0, canvas.width, canvas.height);

                var texture = new THREE.Texture(canvas);
                texture.needsUpdate = true;

                var material = new THREE.SpriteMaterial({
                    map : texture,
                    useScreenCoordinates: false,
                    opacity:0
                    
                    });
                var sprite = new THREE.Sprite(material);
                sprite.position = {x: x*1.1, y: y+20, z: z*1.1};
                sprite.scale.set(canvas.width, canvas.height);
                    new TWEEN.Tween( {opacity: 0})
                        .to( {opacity: 1}, 500 )
                        .onUpdate(function(){
                            material.opacity = this.opacity
                        }).delay(1000)
                        .start();
                return sprite;

                }

            function mapPoint(lat, lng, scale) {
               if(!scale){
                   scale = 500;
               }
               var phi = (90 - lat) * Math.PI / 180;
               var theta = (180 - lng) * Math.PI / 180;
               var x = scale * Math.sin(phi) * Math.cos(theta);
               var y = scale * Math.cos(phi);
               var z = scale * Math.sin(phi) * Math.sin(theta);
               return {x: x, y: y, z:z};
             }



            function onWindowResize( event ) {

                windowHalfX = window.innerWidth / 2;
                windowHalfY = window.innerHeight / 2;

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            //

            function animate() {
                runPointAnimations();
                TWEEN.update();

                requestAnimationFrame( animate );

                render();
                stats.update();

            }

            function render() {


                var renderTime = new Date() - lastRenderDate;
                lastRenderDate = new Date();
                var rotateCameraBy = (2 * Math.PI)/(20000/renderTime);

                cameraAngle += rotateCameraBy;

                camera.position.x = cameraDistance * Math.cos(cameraAngle);
                camera.position.y = 0;
                camera.position.z = cameraDistance * Math.sin(cameraAngle);


                camera.lookAt( scene.position );

                //h = ( 360 * ( 1.0 + time ) % 360 ) / 360;
                // material.color.setHSL( h, 1.0, 0.6 );

                for(var i = 0; i< lineCurves.length; i++){
                    lineCurves[i].rotateY((2 * Math.PI)/(3000/renderTime));
                }


                renderer.render( scene, camera );

            }

            var globeImage = document.getElementById('globeImage');

            var samples = [
            { 
                offsetLat: 0,
                offsetLon: 0,
                incLat: 2,
                incLon: 4
                },
                { 
                    offsetLat: 1,
                    offsetLon: 2,
                    incLat: 2,
                    incLon: 4
                }
                ];

                /* POINTS */

                GLOBEUTILS.landPoints(globeImage, samples, function(points){
                    container = document.createElement( 'div' );
                    document.body.appendChild( container );

                    camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 3000 );
                    camera.position.z = cameraDistance;

                    scene = new THREE.Scene();
                    scene.fog = new THREE.Fog( 0x000000, cameraDistance-200, cameraDistance+550 );

                    geometry = new THREE.Geometry();

                    sprite = THREE.ImageUtils.loadTexture( "hex2.png" );
                    //console.log(points.length);
                    var myColors1 = pusher.color('orange').hueSet();
                    var myColors = [];
                    for(var i = 0; i< myColors1.length; i++){
                        myColors.push(myColors1[i]);

                        myColors.push(myColors1[i].shade(.2 + Math.random()/2.0));
                        myColors.push(myColors1[i].shade(.2 + Math.random()/2.0));
                    }


                    for ( i = 0; i < points.length; i ++ ) {

                        var vertex = new THREE.Vector3();
                        var point = mapPoint(points[i].lat, points[i].lon, 500);
                        var delay = 3000*((180+points[i].lon)/360.0); 

                        vertex.x = 0;
                        vertex.y = 0;
                        vertex.z = cameraDistance+1;

                        geometry.vertices.push( vertex );
                        
                        addPointAnimation(Date.now() + delay, i, {
                            x : point.x*1.05,
                            y : point.y*1.05,
                            z : point.z*1.05});

                        addPointAnimation(Date.now() + delay + 400, i, {
                            x : point.x,
                            y : point.y,
                            z : point.z});

                        colors[ i ] = new THREE.Color( myColors[Math.floor(Math.random() * myColors.length)].hex6());
                        

                    }

                    geometry.colors = colors;

                    material = new THREE.ParticleSystemMaterial( { size: 8 + Math.random()*10, map: sprite, vertexColors: true, transparent: true } );

                    particles = new THREE.ParticleSystem( geometry, material );
                    particles.sortParticles = true;

                    particles.geometry.dynamic=true;


                    scene.add( particles );


                    /* marker things */


                    /* swirly lines */



                    var materialSpline = new THREE.LineBasicMaterial({
                        color: 0x8FD8D8,
                        transparent: true,
                        opacity: 0
                    });
                    geometrySplines = [];
                    lineCurves = [];

                    new TWEEN.Tween( {opacity: 0})
                        .to( {opacity: 1}, 500 )
                        .onUpdate(function(){
                            materialSpline.opacity = this.opacity;
                        })
                        .start();

                    new TWEEN.Tween( {opacity: 1})
                        .to( {opacity: 0}, 500 )
                        .delay(2000)
                        .onUpdate(function(){
                            materialSpline.opacity = this.opacity;

                        })
                        .start();

                    setTimeout(function(){
                        for(var i = 0; i < lineCurves.length; i++){
                            scene.remove(lineCurves[i]);
                        }
                    }, 4200);


                    for(var i = 0; i< 100; i++){
                        geometrySplines[i] = new THREE.Geometry();

                        var lat = Math.random()*180 + 90;
                        var lon =  Math.random()*5-25;
                        var lenBase = 4 + Math.floor(Math.random()*5);
                        var sPoints = [];

                        if(Math.random()<.3){
                           lon = Math.random()*30 - 80;
                           lenBase = 3 + Math.floor(Math.random()*3);

                        }

                        for(var j = 0; j< lenBase; j++){
                            var thisPoint = mapPoint(lat, lon - j * 5);
                            sPoints.push(new THREE.Vector3(thisPoint.x*1.05, thisPoint.y*1.05, thisPoint.z*1.05));
                        }

                        var spline = new THREE.SplineCurve3(sPoints);

                        var splinePoints = spline.getPoints(10);

                        for(var k = 0; k < splinePoints.length; k++){
                            geometrySplines[i].vertices.push(splinePoints[k]);  
                        }
                        lineCurves[i] = new THREE.Line(geometrySplines[i], materialSpline);
                        scene.add(lineCurves[i]);
                    }

                    renderer = new THREE.WebGLRenderer( { clearAlpha: 1 } );
                    renderer.setSize( window.innerWidth, window.innerHeight );
                    container.appendChild( renderer.domElement );

                    stats = new Stats();
                    stats.domElement.style.position = 'absolute';
                    stats.domElement.style.top = '0px';
                    container.appendChild( stats.domElement );

                    window.addEventListener( 'resize', onWindowResize, false );

                    setInterval(function(){
                        addMarker(Math.random()*180 + 90, Math.random()*360+180, "testing");
                    }, 300);

                    animate();


                    });
                </script>
            </body>
        </html>

