
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                background-color: #000000;
                margin: 0px;
                overflow: hidden;
                font-family:Monospace;
                font-size:13px;
                text-align:center;
                font-weight: bold;
                text-align:center;
            }

            a {
                color:#0078ff;
            }

            #info {
                color:#fff;
                position: absolute;
                top: 0px; width: 100%;
                padding: 5px;
                z-index:100;
            }

        </style>
    </head>
    <body>


        <script src="three.min.js"></script>
        <script src="tween.min.js"></script>

        <script src="stats.min.js"></script>
        <script src="pusher.color.js"></script>
        <img id="globeImage" style="display:none" src="equirectangle_projection.png"/>
        <script src="globeutils.js"></script>

        <script>


            var container, stats;
            var camera, scene, renderer, particles, geometry, material, i, h, color, colors = [], sprite, size;
            var mouseX = 0, mouseY = 0;

            var windowHalfX = window.innerWidth / 2;
            var windowHalfY = window.innerHeight / 2;
            cameraDistance = 1500;
            cameraAngle=-2;

            var animations = [];


            function addAnimation(when, verticleIndex, position){
                var pCount = animations.length-1;
                while(pCount > 0 && animations[pCount].when < when){
                    pCount--;
                }
                animations.splice(pCount+1,0, {when: when, verticleIndex: verticleIndex, position: position});
            }

            function runAnimations(){
                var next;

                if(animations.length == 0){
                    return;
                }

                while(animations.length > 0 && (next = animations.pop()).when < Date.now()){
                    particles.geometry.vertices[next.verticleIndex].x = next.position.x;
                    particles.geometry.vertices[next.verticleIndex].y = next.position.y;
                    particles.geometry.vertices[next.verticleIndex].z = next.position.z;

                    particles.geometry.verticesNeedUpdate = true;
                }
                if(next.when >= Date.now()){
                    animations.push(next);

                }

            }


            function init() {

            }

            function mapPoint(lat, lng, scale) {
               if(!scale){
                   scale = 500;
               }
               var phi = (90 - lat) * Math.PI / 180;
               var theta = (180 - lng) * Math.PI / 180;
               var x = scale * Math.sin(phi) * Math.cos(theta);
               var y = scale * Math.cos(phi);
               var z = scale * Math.sin(phi) * Math.sin(theta);
               return {x: x, y: y, z:z};
             }



            function onWindowResize( event ) {

                windowHalfX = window.innerWidth / 2;
                windowHalfY = window.innerHeight / 2;

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            //

            function animate() {
                runAnimations();

                requestAnimationFrame( animate );

                render();
                stats.update();

            }

            function render() {

                var time = Date.now() * 0.00005;

                cameraAngle += .01;

                camera.position.x = cameraDistance * Math.cos(cameraAngle);
                camera.position.y = 0;
                camera.position.z = cameraDistance * Math.sin(cameraAngle);


                camera.lookAt( scene.position );

                //h = ( 360 * ( 1.0 + time ) % 360 ) / 360;
                // material.color.setHSL( h, 1.0, 0.6 );

                for(var i = 0; i< lineCurves.length; i++){
                    lineCurves[i].rotateY(-1 * time / 100);
                }

                renderer.render( scene, camera );

            }

            var globeImage = document.getElementById('globeImage');

            var samples = [
            { 
                offsetLat: 0,
                offsetLon: 0,
                incLat: 2,
                incLon: 4
                },
                { 
                    offsetLat: 1,
                    offsetLon: 2,
                    incLat: 2,
                    incLon: 4
                }
                ];

                /* POINTS */

                GLOBEUTILS.landPoints(globeImage, samples, function(points){
                    container = document.createElement( 'div' );
                    document.body.appendChild( container );

                    camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 3000 );
                    camera.position.z = cameraDistance;

                    scene = new THREE.Scene();
                    scene.fog = new THREE.FogExp2( 0x0000001, 0.0009 );

                    geometry = new THREE.Geometry();

                    sprite = THREE.ImageUtils.loadTexture( "hex2.png" );
                    //console.log(points.length);
                    var myColors1 = pusher.color('orange').hueSet();
                    var myColors = [];
                    for(var i = 0; i< myColors1.length; i++){
                        myColors.push(myColors1[i]);

                        // myColors.push(myColors1[i].shade(.2 + Math.random()/2.0));
                        // myColors.push(myColors1[i].shade(.2 + Math.random()/2.0));
                    }


                    for ( i = 0; i < points.length; i ++ ) {

                        var vertex = new THREE.Vector3();
                        var point = mapPoint(points[i].lat, points[i].lon, 500);
                        var delay = 500+(180+points[i].lon)*8; 

                        vertex.x = 0;
                        vertex.y = 0;
                        vertex.z = 0;

                        geometry.vertices.push( vertex );
                        
                        addAnimation(Date.now() + delay, i, {
                            x : point.x,
                            y : point.y,
                            z : point.z});

                        addAnimation(Date.now() + delay + 300, i, {
                            x : point.x*.95,
                            y : point.y*.95,
                            z : point.z*.95});

                        colors[ i ] = new THREE.Color( myColors[Math.floor(Math.random() * myColors.length)].hex6());
                        

                    }

                    geometry.colors = colors;

                    material = new THREE.ParticleSystemMaterial( { size: 16, map: sprite, vertexColors: true, transparent: true } );
                    //material.color.setHSL( 1.0, 0.2, 0.7 );

                    particles = new THREE.ParticleSystem( geometry, material );
                    particles.sortParticles = true;

                    particles.geometry.dynamic=true;


                    scene.add( particles );


                    /* swirly lines */



                    var materialSpline = new THREE.LineBasicMaterial({
                        color: 0x8FD8D8,
                        opacity: 0
                    });
                    /*
                    setTimeout(function(){
                        materialSpline.opacity = .5;

                    }, 450);
                    setTimeout(function(){
                        materialSpline.opacity = 1;
                    }, 900);

                    setTimeout(function(){
                        materialSpline.opacity = .4;
                    }, 3000);

                    setTimeout(function(){
                        materialSpline.opacity = 0;
                    }, 3100);
                    */
                    setTimeout(function(){
                        for(var i = 0; i < lineCurves.length; i++){
                            scene.remove(lineCurves[i]);
                        }
                    }, 4200);

                    geometrySplines = [];
                    lineCurves = [];

                    for(var i = 0; i< 35; i++){
                        geometrySplines[i] = new THREE.Geometry();

                        var lat = Math.random()*180 + 90;
                        var lon =  Math.random()*10;
                        var lenBase = 5 + Math.floor(Math.random()*8);
                        var sPoints = [];

                        if(Math.random()<.2){
                           lon = Math.random()*20-40;
                            var lenBase = 5 + Math.floor(Math.random()*3);

                        }

                        for(var j = 0; j< lenBase; j++){
                            var thisPoint = mapPoint(lat, lon - j * 5);
                            sPoints.push(new THREE.Vector3(thisPoint.x, thisPoint.y, thisPoint.z));
                        }

                        var spline = new THREE.SplineCurve3(sPoints);

                        var splinePoints = spline.getPoints(10);

                        for(var k = 0; k < splinePoints.length; k++){
                            geometrySplines[i].vertices.push(splinePoints[k]);  
                        }
                        lineCurves[i] = new THREE.Line(geometrySplines[i], materialSpline);
                        scene.add(lineCurves[i]);
                    }

                    renderer = new THREE.WebGLRenderer( { clearAlpha: 1 } );
                    renderer.setSize( window.innerWidth, window.innerHeight );
                    container.appendChild( renderer.domElement );

                    stats = new Stats();
                    stats.domElement.style.position = 'absolute';
                    stats.domElement.style.top = '0px';
                    container.appendChild( stats.domElement );

                    window.addEventListener( 'resize', onWindowResize, false );

                    animate();


                    });
                </script>
            </body>
        </html>

